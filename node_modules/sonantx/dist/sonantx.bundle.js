(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["sonantx"] = factory();
	else
		root["sonantx"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./sonantx.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./sonantx.js":
/*!********************!*\
  !*** ./sonantx.js ***!
  \********************/
/*! exports provided: generateSound, generateSong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateSound\", function() { return generateSound; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateSong\", function() { return generateSong; });\n// Oscillators\nfunction osc_sin(value) {\n  return Math.sin(value * Math.PI * 2);\n}\n\nfunction osc_square(value) {\n  if (osc_sin(value) < 0) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction osc_saw(value) {\n  return value % 1 - 0.5;\n}\n\nfunction osc_tri(value) {\n  const v2 = value % 1 * 4;\n\n  if (v2 < 2) {\n    return v2 - 1;\n  }\n\n  return 3 - v2;\n} // Array of oscillator functions\n\n\nconst oscillators = [osc_sin, osc_square, osc_saw, osc_tri];\n\nfunction getnotefreq44100(n) {\n  const val = 0.00390625 * Math.pow(1.059463094, n - 128);\n  return val;\n}\n\nfunction getnotefreq(audioCtx, n) {\n  const x = getnotefreq44100(n);\n  const val = x / audioCtx.sampleRate * 44100;\n  return val;\n}\n\nfunction effectiveRowLen(audioCtx, bpm) {\n  return Math.round(60 * audioCtx.sampleRate / 4 / bpm);\n}\n\nclass SoundWriter {\n  constructor(audioCtx, instr, n, bpm) {\n    this.audioCtx = audioCtx;\n    this.instr = instr;\n    this.n = n;\n    this.bpm = bpm;\n    this.c1 = 0;\n    this.c2 = 0;\n    this.low = 0;\n    this.band = 0;\n    this.j = 0;\n  }\n\n  write(lchan, rchan, from) {\n    const instr = this.instr;\n    const n = this.n;\n    let c = from;\n    const osc_lfo = oscillators[instr.lfo_waveform];\n    const osc1 = oscillators[instr.osc1_waveform];\n    const osc2 = oscillators[instr.osc2_waveform];\n    const panFreq = Math.pow(2, instr.fx_pan_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);\n    const lfoFreq = Math.pow(2, instr.lfo_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);\n    const attackTime = instr.env_attack / 44100;\n    const releaseTime = instr.env_release / 44100;\n    const sustainTime = instr.env_sustain / 44100;\n    const env_attack = attackTime * this.audioCtx.sampleRate;\n    const env_release = releaseTime * this.audioCtx.sampleRate;\n    const env_sustain = sustainTime * this.audioCtx.sampleRate; // Precalculate frequencues\n\n    const o1t = getnotefreq(this.audioCtx, n + (instr.osc1_oct - 8) * 12 + instr.osc1_det) * (1 + 0.0008 * instr.osc1_detune);\n    const o2t = getnotefreq(this.audioCtx, n + (instr.osc2_oct - 8) * 12 + instr.osc2_det) * (1 + 0.0008 * instr.osc2_detune); // State variable init\n\n    const q = instr.fx_resonance / 255;\n\n    while (this.j < env_attack + env_sustain + env_release && c < lchan.length) {\n      // LFO\n      const lfor = osc_lfo(this.j * lfoFreq) * instr.lfo_amt / 512 + 0.5; // Envelope\n\n      let e = 1;\n\n      if (this.j < env_attack) {\n        e = this.j / env_attack;\n      } else if (this.j >= env_attack + env_sustain) {\n        e -= (this.j - env_attack - env_sustain) / env_release;\n      } // Oscillator 1\n\n\n      let t = o1t;\n\n      if (instr.lfo_osc1_freq) {\n        t += lfor;\n      }\n\n      if (instr.osc1_xenv) {\n        t *= e * e;\n      }\n\n      this.c1 += t;\n      let rsample = osc1(this.c1) * instr.osc1_vol; // Oscillator 2\n\n      t = o2t;\n\n      if (instr.osc2_xenv) {\n        t *= e * e;\n      }\n\n      this.c2 += t;\n      rsample += osc2(this.c2) * instr.osc2_vol; // Noise oscillator\n\n      if (instr.noise_fader) {\n        rsample += (2 * Math.random() - 1) * instr.noise_fader * e;\n      }\n\n      rsample *= e / 255; // State variable filter\n\n      let f = instr.fx_freq;\n\n      if (instr.lfo_fx_freq) {\n        f *= lfor;\n      }\n\n      f = 1.5 * Math.sin(f * Math.PI / this.audioCtx.sampleRate);\n      this.low += f * this.band;\n      const high = q * (rsample - this.band) - this.low;\n      this.band += f * high;\n\n      switch (instr.fx_filter) {\n        case 1:\n          // Hipass\n          rsample = high;\n          break;\n\n        case 2:\n          // Lopass\n          rsample = this.low;\n          break;\n\n        case 3:\n          // Bandpass\n          rsample = this.band;\n          break;\n\n        case 4:\n          // Notch\n          rsample = this.low + high;\n          break;\n\n        default:\n      } // Panning & master volume\n\n\n      t = osc_sin(this.j * panFreq) * instr.fx_pan_amt / 512 + 0.5;\n      rsample *= 39 * instr.env_master;\n      let x = 32768 + rsample * (1 - t);\n      let x1 = x & 255;\n      let x2 = x >> 8 & 255;\n      let y = 4 * (x1 + (x2 << 8) - 32768);\n      y = y < -32768 ? -32768 : y > 32767 ? 32767 : y;\n      lchan[c] = lchan[c] + y / 32768;\n      x = 32768 + rsample * t;\n      x1 = x & 255;\n      x2 = x >> 8 & 255;\n      y = 4 * (x1 + (x2 << 8) - 32768);\n      y = y < -32768 ? -32768 : y > 32767 ? 32767 : y;\n      rchan[c] = rchan[c] + y / 32768;\n      this.j++;\n      c++;\n    } // returns true if the sound finished\n\n\n    if (c < lchan.length) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass TrackGenerator {\n  constructor(audioCtx, instr, bpm, endPattern) {\n    bpm = bpm || 118;\n    endPattern = endPattern || instr.p.length - 1;\n    this.audioCtx = audioCtx;\n    this.instr = instr;\n    this.bpm = bpm;\n    this.endPattern = endPattern;\n    const source = this.audioCtx.createOscillator();\n    const nullGain = this.audioCtx.createGain();\n    nullGain.gain.value = 0;\n    source.connect(nullGain);\n    const scriptNode = this.audioCtx.createScriptProcessor(512, 2, 2);\n    nullGain.connect(scriptNode);\n    let currentSample = 0;\n    let nextNote = 0;\n    let sounds = [];\n\n    scriptNode.onaudioprocess = audioProcessingEvent => {\n      const inputData = audioProcessingEvent.inputBuffer;\n      const outputData = audioProcessingEvent.outputBuffer;\n      const lchan = outputData.getChannelData(0);\n      const rchan = outputData.getChannelData(1);\n      lchan.set(inputData.getChannelData(0));\n      rchan.set(inputData.getChannelData(1));\n      sounds.slice().forEach(el => {\n        const finished = el.write(lchan, rchan, 0);\n\n        if (finished) {\n          sounds = sounds.filter(el2 => {\n            return el2 !== el;\n          });\n        }\n      });\n      let nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);\n\n      while (nextNoteSample >= currentSample && nextNoteSample < currentSample + inputData.length) {\n        const pattern = instr.p[Math.floor(nextNote / 32) % (this.endPattern + 1)] || 0;\n        const note = pattern === 0 ? 0 : (instr.c[pattern - 1] || {\n          n: []\n        }).n[nextNote % 32] || 0;\n\n        if (note !== 0) {\n          const sw = new SoundWriter(this.audioCtx, instr, note, this.bpm);\n          sw.write(lchan, rchan, nextNoteSample - currentSample);\n          sounds.push(sw);\n        }\n\n        nextNote += 1;\n        nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);\n      }\n\n      currentSample += inputData.length;\n    };\n\n    const delayTime = instr.fx_delay_time * (1 / (this.bpm / 60) / 8);\n    const delayAmount = instr.fx_delay_amt / 255;\n    const delayGain = this.audioCtx.createGain();\n    delayGain.gain.value = delayAmount;\n    scriptNode.connect(delayGain);\n    const delay = this.audioCtx.createDelay();\n    delay.delayTime.value = delayTime;\n    delayGain.connect(delay);\n    delay.connect(delayGain);\n    const mixer = this.audioCtx.createGain();\n    mixer.gain.value = 1;\n    scriptNode.connect(mixer);\n    delay.connect(mixer);\n    this.chain = [source, nullGain, scriptNode, delayGain, delay, mixer];\n  }\n\n  start(when) {\n    this.chain[0].start(when);\n  }\n\n  stop(when) {\n    this.chain[0].stop(when);\n    this.chain[this.chain.length - 1].disconnect();\n  }\n\n  connect(target) {\n    this.chain[this.chain.length - 1].connect(target);\n  }\n\n}\n\nclass MusicGenerator {\n  constructor(audioCtx, song) {\n    this.audioCtx = audioCtx;\n    this.song = song;\n    const mixer = this.audioCtx.createGain();\n    mixer.gain.value = 1;\n    this.tracks = [];\n    this.song.songData.forEach(el => {\n      const track = new TrackGenerator(this.audioCtx, el, this.bpm, this.song.endPattern);\n      track.connect(mixer);\n      this.tracks.push(track);\n    });\n    this.chain = [this.tracks, mixer];\n  }\n\n  get bpm() {\n    // rowLen is a number of samples when using 44100hz\n    return Math.round(60 * 44100 / 4 / this.song.rowLen);\n  }\n\n  start(when) {\n    when = when || this.audioCtx.currentTime;\n    this.tracks.forEach(t => t.start(when));\n  }\n\n  stop(when) {\n    when = when || this.audioCtx.currentTime;\n    this.tracks.forEach(t => t.stop(when));\n    this.chain[this.chain.length - 1].disconnect();\n  }\n\n  connect(target) {\n    this.chain[this.chain.length - 1].connect(target);\n  }\n\n}\n/**\n * Generates a single note from an instrument.\n *\n * @param {*} instr The instrument descriptor\n * @param {*} n The note as a midi note\n * @param {*} sampleRate The sample rate\n * @param {*} bpm The bpm of the song\n * @returns {AudioBuffer} The generated audio buffer\n */\n\n\nasync function generateSound(instr, n, sampleRate, bpm = 120) {\n  const attackTime = instr.env_attack / 44100;\n  const releaseTime = instr.env_release / 44100;\n  const sustainTime = instr.env_sustain / 44100;\n  const soundLenSeconds = attackTime + releaseTime + sustainTime + 8 * (1 / (bpm / 60));\n  const nInstr = Object.assign({}, instr);\n  nInstr.p = [1, 0, 0, 0];\n  nInstr.c = [{\n    n: new Array(32).map(() => 0)\n  }];\n  nInstr.c[0].n[0] = n + 75;\n  const audioCtx = new OfflineAudioContext(2, soundLenSeconds * sampleRate, sampleRate);\n  const soundGen = new TrackGenerator(audioCtx, nInstr, bpm, 0);\n  soundGen.connect(audioCtx.destination);\n  soundGen.start();\n  const buf = await audioCtx.startRendering();\n  return buf;\n}\n/**\n * Generates a complete song from a song description.\n *\n * @param {*} song The song description\n * @param {*} options `sampleRate`: the sample rate\n * @returns {AudioBuffer} The generated audio buffer\n */\n\nasync function generateSong(song, sampleRate) {\n  const songLenSeconds = song.songLen;\n  const audioCtx = new OfflineAudioContext(2, songLenSeconds * sampleRate, sampleRate);\n  const soundGen = new MusicGenerator(audioCtx, song);\n  soundGen.connect(audioCtx.destination);\n  soundGen.start();\n  const buf = await audioCtx.startRendering();\n  return buf;\n}\n\n//# sourceURL=webpack://sonantx/./sonantx.js?");

/***/ })

/******/ });
});